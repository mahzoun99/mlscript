class Base1[A]
  method M1: A -> Base1[A]
class Derived1: Base1[int] & { x: int }
  method M1 y = Derived1 { x = add this.x y }
  method M2 = Derived1 { x = add this.x 1 }
class Derived2[C, D]: Base1[{ c: C; d: D }]
  // method M1 { c, d } = Derived2 { c; d }
  method M1 r = Derived2 { c = r.c; d = r.d }
type Type1[A] = Derived1 | Derived2['a, 'b]
//│ Defined class Base1
//│ Declared Base1.M1: (Base1['A] & this) -> 'A -> Base1['A]
//│ Defined class Derived1
//│ Defined Derived1.M1: (Derived1 & this) -> int -> Derived1
//│ Defined Derived1.M2: (Derived1 & this) -> Derived1
//│ Defined class Derived2
//│ Defined Derived2.M1: (Derived2['C, 'D] & this) -> {c: anything, d: anything} -> Derived2['C0, 'D0]
//│ Defined type alias Type1
// class Derived2[C, D]: Base1[C -> D]

def foo b x = case b of {
  | Derived1 -> b.M2
  | Base1 -> b.M1 x
  }
//│ foo: (Base1['A] & this & ~derived1 | Derived1 & this) -> 'A -> (Base1['A] | Derived1)
//│    = [Function: foo]

d1 = Derived1 { x = 1 }
//│ d1: Derived1 & {x: 1}
//│   = Derived1 { x: 1 }

foo d1
foo d1 0
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.31: 	foo d1
//│ ║        	^^^^^^
//│ ╟── application of type `Derived1 & {x: ?x}` is not an instance of type This
//│ ║  l.27: 	d1 = Derived1 { x = 1 }
//│ ║        	     ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `this`
//│ ║  l.31: 	foo d1
//│ ║        	    ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.21: 	  | Derived1 -> b.M2
//│ ║        	                ^
//│ ╟── from reference:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│ res: 'A -> (Base1['A] | Derived1) | error
//│    = [Function (anonymous)]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.32: 	foo d1 0
//│ ║        	^^^^^^
//│ ╟── application of type `Derived1 & {x: ?x}` is not an instance of type This
//│ ║  l.27: 	d1 = Derived1 { x = 1 }
//│ ║        	     ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `this`
//│ ║  l.32: 	foo d1 0
//│ ║        	    ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.21: 	  | Derived1 -> b.M2
//│ ║        	                ^
//│ ╟── from reference:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│ res: Base1['A .. 0 | 'A] | Derived1 | error
//│    = Derived1 { x: 2 }

def bar0: Base1[int] -> int -> Base1[int]
bar0 d1
bar0 d1 0
//│ bar0: Base1[int] -> int -> Base1[int]
//│     = <missing implementation>
//│ res: int -> Base1[int]
//│    = <no result>
//│      bar0 is not implemented
//│ res: Base1[int]
//│    = <no result>
//│      bar0 is not implemented

// This is ill-typed because type `Base1[int]` includes things like `Derived1\x` (a `Derived` instance without an `x` field)
:e
def bar0 = foo
//│ (Base1['A] & this & ~derived1 | Derived1 & this) -> 'A -> (Base1['A] | Derived1)
//│   <:  bar0:
//│ Base1[int] -> int -> Base1[int]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.82: 	def bar0 = foo
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── expression of type `Base1[int] & ~derived1` is not an instance of type This
//│ ╟── Note: constraint arises from reference:
//│ ║  l.22: 	  | Base1 -> b.M1 x
//│ ║        	             ^
//│ ╟── from refined scrutinee:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.82: 	def bar0 = foo
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── expression of type `Base1[int] & ~this` is not an instance of type This
//│ ╟── Note: constraint arises from reference:
//│ ║  l.22: 	  | Base1 -> b.M1 x
//│ ║        	             ^
//│ ╟── from refined scrutinee:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.82: 	def bar0 = foo
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── expression of type `Base1[int] & ~?a | Derived1` is not an instance of type This
//│ ╟── Note: constraint arises from reference:
//│ ║  l.21: 	  | Derived1 -> b.M2
//│ ║        	                ^
//│ ╟── from refined scrutinee:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.82: 	def bar0 = foo
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── expression of type `Base1[int] & ~?a | Derived1` does not have field 'x'
//│ ╟── Note: constraint arises from record type:
//│ ║  l.3: 	class Derived1: Base1[int] & { x: int }
//│ ║       	                             ^^^^^^^^^^
//│ ╟── from refined scrutinee:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│     = [Function: foo]

def bar1: Type1[int] -> int -> Type1[int]
bar1 d1
bar1 d1 0
//│ bar1: ((Derived1 | Derived2['a, 'b],) & {_1: Derived1 | Derived2[?, ?]}) -> int -> (Derived1 | Derived2['a0, 'b0])
//│     = <missing implementation>
//│ res: int -> (Derived1 | Derived2['a, 'b])
//│    = <no result>
//│      bar1 is not implemented
//│ res: Derived1 | Derived2['a, 'b]
//│    = <no result>
//│      bar1 is not implemented

:e
def bar1 = foo
//│ (Base1['A] & this & ~derived1 | Derived1 & this) -> 'A -> (Base1['A] | Derived1)
//│   <:  bar1:
//│ ((Derived1 | Derived2['a, 'b],) & {_1: Derived1 | Derived2[?, ?]}) -> int -> (Derived1 | Derived2['a0, 'b0])
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `Derived1` is not an instance of type This
//│ ║  l.9: 	type Type1[A] = Derived1 | Derived2['a, 'b]
//│ ║       	                ^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.21: 	  | Derived1 -> b.M2
//│ ║        	                ^
//│ ╟── from reference:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `Derived2[?a, ?b]` is not an instance of type This
//│ ║  l.9: 	type Type1[A] = Derived1 | Derived2['a, 'b]
//│ ║       	                           ^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.22: 	  | Base1 -> b.M1 x
//│ ║        	             ^
//│ ╟── from reference:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `int` is not a record (expected a record with fields: c, d)
//│ ║  l.128: 	def bar1: Type1[int] -> int -> Type1[int]
//│ ║         	                        ^^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.6: 	class Derived2[C, D]: Base1[{ c: C; d: D }]
//│ ║       	                            ^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.22: 	  | Base1 -> b.M1 x
//│ ╙──      	                  ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `Base1[?A]` does not match type `Derived1 | Derived2[?a, ?b]`
//│ ║  l.2: 	  method M1: A -> Base1[A]
//│ ║       	                  ^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.9: 	type Type1[A] = Derived1 | Derived2['a, 'b]
//│ ║       	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.128: 	def bar1: Type1[int] -> int -> Type1[int]
//│ ╙──       	                               ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `int` is not a record (expected a record with fields: c, d)
//│ ║  l.128: 	def bar1: Type1[int] -> int -> Type1[int]
//│ ║         	                        ^^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.6: 	class Derived2[C, D]: Base1[{ c: C; d: D }]
//│ ╙──     	                            ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `Base1[?A]` does not match type `Derived1 | Derived2[?a, ?b]`
//│ ║  l.2: 	  method M1: A -> Base1[A]
//│ ║       	                  ^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.9: 	type Type1[A] = Derived1 | Derived2['a, 'b]
//│ ║       	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.128: 	def bar1: Type1[int] -> int -> Type1[int]
//│ ╙──       	                               ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `Base1[?A]` does not match type `Derived1 | Derived2[?a, ?b]`
//│ ║  l.2: 	  method M1: A -> Base1[A]
//│ ║       	                  ^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.9: 	type Type1[A] = Derived1 | Derived2['a, 'b]
//│ ║       	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.128: 	def bar1: Type1[int] -> int -> Type1[int]
//│ ╙──       	                               ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `{c: ?a, d: ?b}` does not match type `int`
//│ ║  l.6: 	class Derived2[C, D]: Base1[{ c: C; d: D }]
//│ ║       	                            ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.3: 	class Derived1: Base1[int] & { x: int }
//│ ╙──     	                      ^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `{c: ?a, d: ?b}` does not match type `int`
//│ ║  l.6: 	class Derived2[C, D]: Base1[{ c: C; d: D }]
//│ ║       	                            ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.3: 	class Derived1: Base1[int] & { x: int }
//│ ╙──     	                      ^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	def bar1 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `Base1[?A]` does not match type `Derived1 | Derived2[?a, ?b]`
//│ ║  l.2: 	  method M1: A -> Base1[A]
//│ ║       	                  ^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.9: 	type Type1[A] = Derived1 | Derived2['a, 'b]
//│ ║       	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.128: 	def bar1: Type1[int] -> int -> Type1[int]
//│ ╙──       	                               ^^^^^^^^^^
//│     = [Function: foo]

def bar2: Base1['a] -> 'a -> Base1['a]
bar2 d1
bar2 d1 0
//│ bar2: Base1['a] -> 'a -> Base1['a]
//│     = <missing implementation>
//│ res: int -> Base1[int]
//│    = <no result>
//│      bar2 is not implemented
//│ res: Base1[int]
//│    = <no result>
//│      bar2 is not implemented

// Note that typing this would require GADT reasoning! Though it also suffers from the previous "Derived1 with missing x field" problem.
:e
def bar2 = foo
//│ (Base1['A] & this & ~derived1 | Derived1 & this) -> 'A -> (Base1['A] | Derived1)
//│   <:  bar2:
//│ Base1['a] -> 'a -> Base1['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.272: 	def bar2 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── expression of type `Base1['a] & ~derived1` is not an instance of type This
//│ ╟── Note: constraint arises from reference:
//│ ║  l.22: 	  | Base1 -> b.M1 x
//│ ║        	             ^
//│ ╟── from refined scrutinee:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.272: 	def bar2 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── expression of type `Base1['a] & ~this` is not an instance of type This
//│ ╟── Note: constraint arises from reference:
//│ ║  l.22: 	  | Base1 -> b.M1 x
//│ ║        	             ^
//│ ╟── from refined scrutinee:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.272: 	def bar2 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── expression of type `Base1['a] & ~?a | Derived1` is not an instance of type This
//│ ╟── Note: constraint arises from reference:
//│ ║  l.21: 	  | Derived1 -> b.M2
//│ ║        	                ^
//│ ╟── from refined scrutinee:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.272: 	def bar2 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type 'a
//│ ║  l.3: 	class Derived1: Base1[int] & { x: int }
//│ ║       	                      ^^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.258: 	def bar2: Base1['a] -> 'a -> Base1['a]
//│ ╙──       	                ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.272: 	def bar2 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── type `'a` does not match type `int`
//│ ║  l.258: 	def bar2: Base1['a] -> 'a -> Base1['a]
//│ ║         	                ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.3: 	class Derived1: Base1[int] & { x: int }
//│ ╙──     	                      ^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.272: 	def bar2 = foo
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── expression of type `Base1['a] & ~?a | Derived1` does not have field 'x'
//│ ╟── Note: constraint arises from record type:
//│ ║  l.3: 	class Derived1: Base1[int] & { x: int }
//│ ║       	                             ^^^^^^^^^^
//│ ╟── from refined scrutinee:
//│ ║  l.20: 	def foo b x = case b of {
//│ ╙──      	                   ^
//│     = [Function: foo]

